其实是一种更简单的方式，shader是直接用C写的。在graphics.h文件里面定义了通用的vertex_shader_t
和fragment_shader_t函数指针类型。编写各种shader函数时只要匹配这两种函数指针类型就能用通用的
program_create函数创建一个可用的program用于渲染了。

渲染的流程是这样的：
①我们需要先填充三角形的3个顶点的输入属性信息（比如位置、UV等）到attribs中；
②渲染器会对3个顶点都调用顶点着色器函数，顶点着色器要填充顶点的输出属性信息到varyings中，还要
输出一个vec4_t的齐次坐标用于光栅化；
③在光栅化的过程中，对于每个像素点，渲染器都会算出其重心坐标，然后用重心坐标对3个varyings进行
插值；
④渲染器对每个像素点调用像素着色器函数（以插值后得到的varyings作为输入），像素着色器最后输出一
个vec4_t的颜色值。


看起来应该是因为没有建立合适的类导致的。重点需要三个类，一个是场景类scene，一个是模型类model，
最后一个是相机类camera。scene类中记录了场景中的光照信息、camera和多个model。model类中记录
了一个模型的mesh信息、贴图信息、位移旋转缩放等。camera类中记录了相机的位置和朝向。渲染的时候，
首先从camera中计算出vp矩阵，然后对于scene中的每个model，
①绑定它的mesh和贴图，
②通过设置uniform的方式把光照信息传到shader中，
③从模型的位移旋转缩放信息计算出m矩阵，乘以vp矩阵得到mvp矩阵，
④通过设置uniform的方式把mvp矩阵传到shader中，
⑤调用draw命令来绘制这个模型。这样就可以实现模型、相机、光照的解耦了。