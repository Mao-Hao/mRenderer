-2020/1/7
	正式动工
	查阅了一些windows编程相关知识

-2020/1/8
	开始win32.h的编写
		发现memset有坑，会对每个字节set同样的val
	编写了一些工具宏

-2020/1/9
	win32.h v0.1完成
		实现了基本的双缓冲绘制
		基本的colorbuffer
	mMath.hpp 动工
		了解了偏特化
		用模板的偏特化实现了vec
			真的很麻烦，看的头疼
			用模板是否是一个错误的做法？
	思考：
		win32.h 应该属于什么层次？
		zbuffer是否应在此加入？
		颜色的类型需要一个uint和vec3i之间的转换，这个转换在哪一层实现？
	
-2020/1/11
	搭建了一个NAS，用于Final的版本控制和云备份
	抄了一堆现成的代码，完成了部分数学库

-2020/1/12 - 2020/1/14
	停工，忙
	思考:
		关于API的设计......
			我想，我应该不需要动态的创建mImage
			mImage m，我只需要一个它的实例，它包含了w, h, zbuffer, colorbuffer等信息
			我不希望类似line()这样的函数需要给出一个类似 mImage & m 这样的参数
			mImage设计成一个单例可能会带来更多的好处
			但同时存在一个问题，m的buffer，比如cb，是在win32 init的时候才分配的内存

-2020/1/15
	重构了mImage，现在它叫mDevice了，算是单例
	提出一种方案，uint类型的rawcolor与mColor类型的转换应该在setPixel/getColor这一层实现
		好处：上层统一了，可以实现RGB的float化
		坏处：相当于多了一个中间层，会损失一定的效率
		可能的改进：raw->mcolor的改变应用较多，内联的asm可能有所帮助（需验证

-2020/1/20
	Todo：
		将绘制多线程化，初步打算使用openmp
		将部分计算放在显卡上，初步考虑cuda
		需要一个调试窗口，输出FPS等信息判断性能
	
	修正了一个重构带来的巨大的错误

	开始思考一个问题，目前所有绘制API都是int的，有必要换成float吗

-2020/1/27
	重构了mColor，将其极度简化，并在上层允许float运算了
	定义了顶点数据类型，目前包含颜色和坐标两个属性
	完成了重心插值的三角形画法，包含一个可以根据给定顶点颜色插值的版本
	直线绘制函数新增了一个根据顶点颜色插值的版本
	Todo：
	 	z-buffer
		摄像机
		mesh

-2020/1/29
	记得看 renderer里maths.h文件的618行
	动态分派（Dynamic Dispatch）和静态分派（Static Dispatch